/**
* ROLES AND PERMISSIONS
* Note: 定义应用的角色和权限
*/
-- 自定义角色和权限类型
create type app_role as enum ('admin', 'moderator', 'user');
create type app_permission as enum (
  'users.read', 
  'users.write', 
  'content.create', 
  'content.delete', 
  'models.create', 
  'models.update', 
  'models.delete', 
  'models.approve',
  'comments.moderate'
);

-- 用户角色表
create table user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role app_role not null default 'user',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (user_id, role)
);
comment on table user_roles is '用户角色关联表';

-- 角色权限表
create table role_permissions (
  id bigint generated by default as identity primary key,
  role app_role not null,
  permission app_permission not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (role, permission)
);
comment on table role_permissions is '角色权限关联表';

-- 角色权限初始数据
insert into role_permissions (role, permission)
values
  -- 管理员权限
  ('admin', 'users.read'),
  ('admin', 'users.write'),
  ('admin', 'content.create'),
  ('admin', 'content.delete'),
  ('admin', 'models.create'),
  ('admin', 'models.update'),
  ('admin', 'models.delete'),
  ('admin', 'models.approve'),
  ('admin', 'comments.moderate'),
  
  -- 版主权限
  ('moderator', 'users.read'),
  ('moderator', 'content.create'),
  ('moderator', 'content.delete'),
  ('moderator', 'models.approve'),
  ('moderator', 'comments.moderate'),
  ('moderator', 'models.create'),
  
  -- 普通用户权限
  ('user', 'users.read'),
  ('user', 'content.create'),
  ('user', 'models.create');

-- 授权函数
create or replace function authorize(
  requested_permission app_permission
) returns boolean as $$
declare
  bind_permissions int;
  user_role app_role;
begin
  -- 获取用户角色
  select role into user_role from user_roles where user_id = auth.uid() limit 1;
  
  -- 如果没有找到角色，默认为普通用户
  if user_role is null then
    user_role := 'user';
  end if;
  
  -- 检查权限
  select count(*)
  into bind_permissions
  from role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;
  
  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer;

-- 获取当前用户角色函数
create or replace function get_my_role()
returns app_role as $$
declare
  user_role app_role;
begin
  select role into user_role from user_roles where user_id = auth.uid() limit 1;
  return coalesce(user_role, 'user'::app_role);
end;
$$ language plpgsql stable security definer;

/**
* USERS
* Note: 该表包含用户数据。用户只能查看和更新自己的数据。
*/
create table users (
  -- UUID from auth.users
  id uuid references auth.users not null primary key,
  full_name text,
  user_name text unique,
  avatar_url text,
  email text unique,
  bio text,
  gender varchar(10),
  birthday date,
  is_deleted boolean default false,  -- 逻辑删除标记
  deletion_date timestamp with time zone, -- 逻辑删除时间
  last_login_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  follower_count int default 0,
  following_count int default 0
);

-- 创建索引以提高查询性能
create index idx_users_user_name on users(user_name);
create index idx_users_email on users(email);
create index idx_users_is_deleted on users(is_deleted);

-- 启用行级安全策略
alter table users enable row level security;

-- 查询策略（考虑逻辑删除状态）
create policy "可以查看自己的用户数据" on users
  for select using (auth.uid() = id);

create policy "只能查看未删除的其他用户数据" on users
  for select using (auth.uid() != id and not is_deleted);

create policy "管理员可以查看所有用户数据" on users
  for select using (authorize('users.read'));

-- 更新策略
create policy "可更新自己的用户数据" on users
  for update using (auth.uid() = id and not is_deleted);

create policy "管理员可以更新所有用户数据" on users
  for update using (authorize('users.write'));

-- 插入策略
create policy "自己的用户数据只能由自己创建" on users
  for insert with check (auth.uid() = id);

-- 删除策略（阻止物理删除）
create policy "禁止物理删除用户数据" on users
  for delete using (false);

-- 添加自动更新时间戳触发器
create or replace function update_modified_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger update_users_modtime
  before update on users
  for each row
  execute procedure update_modified_column();

-- 修改逻辑删除用户函数
create or replace function soft_delete_user(user_id uuid)
returns void as $$
declare
  user_email text;
  user_name text;
begin
  -- 获取当前email和user_name
  select email, user_name into user_email, user_name 
  from users 
  where id = user_id;
  
  -- 更新用户状态为已删除，并修改唯一字段
  update users
  set 
    is_deleted = true,
    deletion_date = now(),
    updated_at = now(),
    -- 修改email和user_name以释放这些值供新用户使用
    email = 'deleted_' || substr(md5(user_email || now()::text), 1, 10) || '@deleted.user',
    user_name = 'deleted_' || substr(md5(user_name || now()::text), 1, 10)
  where id = user_id;
end;
$$ language plpgsql security definer;

-- 添加用户注册前检查函数
create or replace function check_user_registration()
returns trigger as $$
declare
  existing_deleted_user_id uuid;
begin
  -- 检查要注册的邮箱是否曾经注册过且被删除
  select id into existing_deleted_user_id
  from users
  where 
    email like 'deleted_%@deleted.user' and
    is_deleted = true and
    new.email = any(string_to_array(regexp_replace(email, '^deleted_[a-f0-9]+@deleted\.user$', ''), '@'));
    
  -- 如果找到删除的旧用户，记录关联（可选）
  if existing_deleted_user_id is not null then
    -- 可以在这里添加代码来记录关联，例如插入到用户关联表中
    -- insert into user_previous_accounts (new_id, old_id) values (new.id, existing_deleted_user_id);
    null; -- 不做任何事，只是占位
  end if;
  
  return new;
end;
$$ language plpgsql security definer;

-- 添加检查触发器（可选）
create trigger before_user_insert
  after insert on auth.users
  for each row
  execute procedure check_user_registration();

-- 唯一索引需要考虑删除状态
drop index if exists idx_users_email;
drop index if exists idx_users_user_name;

-- 修改唯一约束为部分唯一索引（只对未删除的用户生效）
create unique index idx_users_email_unique on users (email) where (not is_deleted);
create unique index idx_users_user_name_unique on users (user_name) where (not is_deleted);

-- 添加最后登录时间触发器
create or replace function update_last_login()
returns trigger as $$
begin
  update users
  set 
    last_login_at = now(),
    updated_at = now()
  where id = new.id;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_login
  after update on auth.users
  for each row
  when (old.last_sign_in_at is distinct from new.last_sign_in_at)
  execute procedure update_last_login();

/**
* 当新用户通过 Supabase Auth 注册时，此触发器会自动创建一个用户条目。
*/
create or replace function public.handle_new_user()
returns trigger as
$$
  begin
    insert into public.users (id, full_name, user_name, avatar_url, email)
    values (
      new.id, 
      coalesce(new.raw_user_meta_data->>'full_name', ''), 
      coalesce(
        new.raw_user_meta_data->>'user_name', 
        'user_' || substr(md5(random()::text), 1, 10)
      ), 
      coalesce(new.raw_user_meta_data->>'avatar_url', ''),
      new.email
    );
    
    -- 为新用户分配默认角色
    insert into public.user_roles (user_id, role)
    values (new.id, 'user');
    
    return new;
  exception
    when others then
      -- 记录错误但不中断认证流程
      return new;
  end;
$$
language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row
    execute procedure public.handle_new_user();

-- 自定义访问令牌钩子函数
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
volatile as $$
  declare
    claims jsonb;
    user_role app_role;
    is_user_deleted boolean;
  begin
    -- 检查用户是否被删除
    select is_deleted into is_user_deleted 
    from users 
    where id = (event->>'user_id')::uuid 
    limit 1;
    
    -- 如果用户被删除，则拒绝访问
    if is_user_deleted then
      return null; -- 返回 null 终止认证过程
    end if;
    
    -- 获取用户角色
    select role into user_role 
    from user_roles 
    where user_id = (event->>'user_id')::uuid 
    limit 1;
    
    -- 设置默认角色
    if user_role is null then
      user_role := 'user';
    end if;
    
    claims := event->'claims';
    -- 设置角色声明
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    -- 更新原始事件中的声明对象
    event := jsonb_set(event, '{claims}', claims);
    
    return event;
  end;
$$;

/**
* 3D 模型相关表
* Note: 3D模型社区核心数据结构
*/

-- 模型分类表
create table model_categories (
  id bigint generated by default as identity primary key,
  name text not null,
  description text,
  parent_id bigint references model_categories(id),
  thumbnail_url text,
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table model_categories is '3D模型分类';

-- 添加索引
create index idx_model_categories_parent_id on model_categories(parent_id);
create index idx_model_categories_is_active on model_categories(is_active);

-- 3D模型表
create table models (
  id uuid default gen_random_uuid() primary key,
  title text not null,
  description text,
  user_id uuid references users(id) not null,
  category_id bigint references model_categories(id),
  thumbnail_url text,
  model_url text not null,
  file_format text not null,
  file_size bigint,
  polygon_count integer,
  is_free boolean default true,
  price decimal(10, 2) default 0,
  is_approved boolean default false,
  approval_date timestamp with time zone,
  approved_by uuid references users(id),
  view_count integer default 0,
  download_count integer default 0,
  like_count integer default 0,
  is_featured boolean default false,
  is_deleted boolean default false,
  deletion_date timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  collection_count int default 0
);
comment on table models is '3D模型数据';

-- 添加索引
create index idx_models_user_id on models(user_id);
create index idx_models_category_id on models(category_id);
create index idx_models_is_approved on models(is_approved);
create index idx_models_is_featured on models(is_featured);
create index idx_models_is_deleted on models(is_deleted);

-- 启用行级安全策略
alter table models enable row level security;

-- 查询策略（考虑逻辑删除状态）
create policy "所有人都可以查看已批准且未删除的模型" on models
  for select using (is_approved and not is_deleted);
  
create policy "用户可以查看自己上传的所有模型" on models
  for select using (auth.uid() = user_id);
  
create policy "管理员和版主可以查看所有模型" on models
  for select using (authorize('models.approve'));

-- 插入策略
create policy "用户可以上传自己的模型" on models
  for insert with check (auth.uid() = user_id);

-- 更新策略
create policy "用户可以更新自己的未批准模型" on models
  for update using (
    auth.uid() = user_id and 
    not is_approved and 
    not is_deleted
  );

create policy "管理员可以更新所有模型" on models
  for update using (authorize('models.update'));
  
create policy "版主可以审批模型" on models
  for update using (
    authorize('models.approve') and 
    new.is_approved is distinct from old.is_approved
  );

-- 删除策略（阻止物理删除）
create policy "禁止物理删除模型" on models
  for delete using (false);

-- 添加自动更新时间戳触发器
create trigger update_models_modtime
  before update on models
  for each row
  execute procedure update_modified_column();

-- 模型标签表
create table model_tags (
  id bigint generated by default as identity primary key,
  model_id uuid references models(id) not null,
  tag_name text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(model_id, tag_name)
);
comment on table model_tags is '模型标签';

-- 添加索引
create index idx_model_tags_model_id on model_tags(model_id);
create index idx_model_tags_tag_name on model_tags(tag_name);

-- 模型评论表
create table model_comments (
  id uuid default gen_random_uuid() primary key,
  model_id uuid references models(id) not null,
  user_id uuid references users(id) not null,
  parent_id uuid references model_comments(id),
  content text not null,
  is_deleted boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table model_comments is '模型评论';

-- 添加索引
create index idx_model_comments_model_id on model_comments(model_id);
create index idx_model_comments_user_id on model_comments(user_id);
create index idx_model_comments_parent_id on model_comments(parent_id);
create index idx_model_comments_is_deleted on model_comments(is_deleted);

-- 启用行级安全策略
alter table model_comments enable row level security;

-- 查询策略
create policy "所有人都可以查看未删除的评论" on model_comments
  for select using (not is_deleted);

-- 插入策略
create policy "认证用户可以发表评论" on model_comments
  for insert with check (auth.uid() = user_id);

-- 更新策略
create policy "用户可以编辑自己的评论" on model_comments
  for update using (auth.uid() = user_id and not is_deleted);
  
create policy "版主和管理员可以编辑所有评论" on model_comments
  for update using (authorize('comments.moderate'));

-- 删除策略（阻止物理删除）
create policy "禁止物理删除评论" on model_comments
  for delete using (false);

-- 添加自动更新时间戳触发器
create trigger update_model_comments_modtime
  before update on model_comments
  for each row
  execute procedure update_modified_column();

-- 模型点赞表
create table model_likes (
  id bigint generated by default as identity primary key,
  model_id uuid references models(id) not null,
  user_id uuid references users(id) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(model_id, user_id)
);
comment on table model_likes is '模型点赞';

-- 添加索引
create index idx_model_likes_model_id on model_likes(model_id);
create index idx_model_likes_user_id on model_likes(user_id);

-- 启用行级安全策略
alter table model_likes enable row level security;

-- 查询策略
create policy "所有人都可以查看点赞" on model_likes
  for select using (true);

-- 插入策略
create policy "认证用户可以点赞" on model_likes
  for insert with check (auth.uid() = user_id);

-- 删除策略
create policy "用户可以取消自己的点赞" on model_likes
  for delete using (auth.uid() = user_id);

-- 点赞触发器函数（更新模型点赞计数）
create or replace function update_model_like_count()
returns trigger as $$
begin
  if TG_OP = 'INSERT' then
    update models
    set like_count = like_count + 1
    where id = new.model_id;
  elsif TG_OP = 'DELETE' then
    update models
    set like_count = like_count - 1
    where id = old.model_id;
  end if;
  return null;
end;
$$ language plpgsql security definer;

-- 添加点赞触发器
create trigger on_model_like_change
  after insert or delete on model_likes
  for each row
  execute procedure update_model_like_count();

-- 为 user_roles 表启用行级安全
alter table user_roles
  enable row level security;

-- 用户可以查看自己的角色
create policy "用户可以查看自己的角色" on user_roles
  for select using (auth.uid() = user_id);

-- 管理员可以查看所有角色
create policy "管理员可以查看所有角色" on user_roles
  for select using (authorize('users.read'));

-- 只有管理员可以修改角色
create policy "管理员可以插入角色" on user_roles
  for insert with check (authorize('users.write'));

create policy "管理员可以更新角色" on user_roles
  for update using (authorize('users.write'));

create policy "管理员可以删除角色" on user_roles
  for delete using (authorize('users.write'));

-- 添加自动更新时间戳触发器
create trigger update_user_roles_modtime
  before update on user_roles
  for each row
  execute procedure update_modified_column();

-- 为 role_permissions 表启用行级安全
alter table role_permissions
  enable row level security;

-- 允许所有用户查看角色权限（这是公开信息）
create policy "所有用户可以查看角色权限" on role_permissions
  for select to authenticated using (true);

-- 只有管理员可以修改角色权限
create policy "只有管理员可以插入角色权限" on role_permissions
  for insert with check (authorize('users.write'));

create policy "只有管理员可以更新角色权限" on role_permissions
  for update using (authorize('users.write'));

create policy "只有管理员可以删除角色权限" on role_permissions
  for delete using (authorize('users.write'));

-- 授予权限
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
grant all on table public.user_roles to supabase_auth_admin;
revoke all on table public.user_roles from authenticated, anon, public;

/**
* 用户关系和互动
* Note: 用户关注、收藏和互动相关表
*/

-- 用户关注表
create table user_follows (
  id bigint generated by default as identity primary key,
  follower_id uuid references users(id) not null, -- 关注者
  followed_id uuid references users(id) not null, -- 被关注者
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(follower_id, followed_id)
);
comment on table user_follows is '用户关注关系';

-- 添加索引
create index idx_user_follows_follower_id on user_follows(follower_id);
create index idx_user_follows_followed_id on user_follows(followed_id);

-- 启用行级安全策略
alter table user_follows enable row level security;

-- 查询策略
create policy "任何人都可以查看关注关系" on user_follows
  for select using (true);
  
-- 插入策略
create policy "认证用户可以关注他人" on user_follows
  for insert with check (auth.uid() = follower_id);
  
-- 删除策略
create policy "用户可以取消关注" on user_follows
  for delete using (auth.uid() = follower_id);

-- 添加自动更新时间戳触发器
create trigger update_user_follows_modtime
  before update on user_follows
  for each row
  execute procedure update_modified_column();

-- 关注计数统计
create or replace function update_user_follow_count()
returns trigger as $$
begin
  if TG_OP = 'INSERT' then
    -- 更新被关注者的粉丝计数
    update users
    set follower_count = follower_count + 1
    where id = new.followed_id;
    
    -- 更新关注者的关注计数
    update users
    set following_count = following_count + 1
    where id = new.follower_id;
  elsif TG_OP = 'DELETE' then
    -- 更新被关注者的粉丝计数
    update users
    set follower_count = follower_count - 1
    where id = old.followed_id;
    
    -- 更新关注者的关注计数
    update users
    set following_count = following_count - 1
    where id = old.follower_id;
  end if;
  return null;
end;
$$ language plpgsql security definer;

-- 添加关注计数触发器
create trigger on_user_follow_change
  after insert or delete on user_follows
  for each row
  execute procedure update_user_follow_count();

-- 模型收藏表
create table model_collections (
  id bigint generated by default as identity primary key,
  model_id uuid references models(id) not null,
  user_id uuid references users(id) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(model_id, user_id)
);
comment on table model_collections is '模型收藏';

-- 添加索引
create index idx_model_collections_model_id on model_collections(model_id);
create index idx_model_collections_user_id on model_collections(user_id);

-- 启用行级安全策略
alter table model_collections enable row level security;

-- 查询策略
create policy "所有人都可以查看收藏记录" on model_collections
  for select using (true);

-- 插入策略
create policy "认证用户可以收藏模型" on model_collections
  for insert with check (auth.uid() = user_id);

-- 删除策略
create policy "用户可以取消收藏" on model_collections
  for delete using (auth.uid() = user_id);

-- 添加自动更新时间戳触发器
create trigger update_model_collections_modtime
  before update on model_collections
  for each row
  execute procedure update_modified_column();

-- 收藏计数触发器函数
create or replace function update_model_collection_count()
returns trigger as $$
begin
  if TG_OP = 'INSERT' then
    update models
    set collection_count = collection_count + 1
    where id = new.model_id;
  elsif TG_OP = 'DELETE' then
    update models
    set collection_count = collection_count - 1
    where id = old.model_id;
  end if;
  return null;
end;
$$ language plpgsql security definer;

-- 添加收藏计数触发器
create trigger on_model_collection_change
  after insert or delete on model_collections
  for each row
  execute procedure update_model_collection_count();

-- 模型下载记录表
create table model_downloads (
  id bigint generated by default as identity primary key,
  model_id uuid references models(id) not null,
  user_id uuid references users(id) not null,
  download_date timestamp with time zone default timezone('utc'::text, now()) not null,
  ip_address text,
  user_agent text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table model_downloads is '模型下载记录';

-- 添加索引
create index idx_model_downloads_model_id on model_downloads(model_id);
create index idx_model_downloads_user_id on model_downloads(user_id);
create index idx_model_downloads_download_date on model_downloads(download_date);

-- 启用行级安全策略
alter table model_downloads enable row level security;

-- 查询策略
create policy "模型创建者可以查看谁下载了他的模型" on model_downloads
  for select using (
    exists (
      select 1 from models
      where models.id = model_downloads.model_id
      and models.user_id = auth.uid()
    )
  );

create policy "用户可以查看自己的下载记录" on model_downloads
  for select using (auth.uid() = user_id);

create policy "管理员可以查看所有下载记录" on model_downloads
  for select using (authorize('users.read'));

-- 插入策略
create policy "认证用户可以添加下载记录" on model_downloads
  for insert with check (auth.uid() = user_id);

-- 下载计数触发器函数
create or replace function update_model_download_count()
returns trigger as $$
begin
  update models
  set download_count = download_count + 1
  where id = new.model_id;
  return null;
end;
$$ language plpgsql security definer;

-- 添加下载计数触发器
create trigger on_model_download
  after insert on model_downloads
  for each row
  execute procedure update_model_download_count();

/**
* 便捷视图
* Note: 提供用户关系和模型交互的查询视图
*/

-- 用户关注列表视图
create or replace view user_following_view as
select 
  f.follower_id as user_id,
  f.followed_id,
  u.user_name as followed_user_name,
  u.full_name as followed_full_name,
  u.avatar_url as followed_avatar_url,
  f.created_at as follow_date
from 
  user_follows f
  join users u on f.followed_id = u.id
where 
  not u.is_deleted;

-- 用户粉丝列表视图
create or replace view user_followers_view as
select 
  f.followed_id as user_id,
  f.follower_id,
  u.user_name as follower_user_name,
  u.full_name as follower_full_name,
  u.avatar_url as follower_avatar_url,
  f.created_at as follow_date
from 
  user_follows f
  join users u on f.follower_id = u.id
where 
  not u.is_deleted;

-- 模型点赞用户视图
create or replace view model_likers_view as
select 
  l.model_id,
  l.user_id,
  u.user_name,
  u.full_name,
  u.avatar_url,
  l.created_at as like_date
from 
  model_likes l
  join users u on l.user_id = u.id
where 
  not u.is_deleted;

-- 模型收藏用户视图
create or replace view model_collectors_view as
select 
  c.model_id,
  c.user_id,
  u.user_name,
  u.full_name,
  u.avatar_url,
  c.created_at as collection_date
from 
  model_collections c
  join users u on c.user_id = u.id
where 
  not u.is_deleted;

-- 模型下载用户视图
create or replace view model_downloaders_view as
select 
  d.model_id,
  d.user_id,
  u.user_name,
  u.full_name,
  u.avatar_url,
  d.download_date
from 
  model_downloads d
  join users u on d.user_id = u.id
where 
  not u.is_deleted;

/**
* 用户互动查询函数
* Note: 提供方便的函数用于查询互动数据
*/

-- 获取用户关注列表
create or replace function get_user_following(user_uuid uuid)
returns setof user_following_view as $$
begin
  return query
  select * from user_following_view
  where user_id = user_uuid
  order by follow_date desc;
end;
$$ language plpgsql stable;

-- 获取用户粉丝列表
create or replace function get_user_followers(user_uuid uuid)
returns setof user_followers_view as $$
begin
  return query
  select * from user_followers_view
  where user_id = user_uuid
  order by follow_date desc;
end;
$$ language plpgsql stable;

-- 获取点赞模型的用户
create or replace function get_model_likers(model_uuid uuid)
returns setof model_likers_view as $$
begin
  return query
  select * from model_likers_view
  where model_id = model_uuid
  order by like_date desc;
end;
$$ language plpgsql stable;

-- 获取收藏模型的用户
create or replace function get_model_collectors(model_uuid uuid)
returns setof model_collectors_view as $$
begin
  return query
  select * from model_collectors_view
  where model_id = model_uuid
  order by collection_date desc;
end;
$$ language plpgsql stable;

-- 获取下载模型的用户
create or replace function get_model_downloaders(model_uuid uuid)
returns setof model_downloaders_view as $$
begin
  return query
  select * from model_downloaders_view
  where model_id = model_uuid
  order by download_date desc;
end;
$$ language plpgsql stable;

-- 检查用户是否关注了另一个用户
create or replace function is_following(follower_uuid uuid, followed_uuid uuid)
returns boolean as $$
declare
  follow_exists boolean;
begin
  select exists(
    select 1 from user_follows
    where follower_id = follower_uuid and followed_id = followed_uuid
  ) into follow_exists;
  
  return follow_exists;
end;
$$ language plpgsql stable;

-- 检查用户是否喜欢了模型
create or replace function has_liked_model(user_uuid uuid, model_uuid uuid)
returns boolean as $$
declare
  like_exists boolean;
begin
  select exists(
    select 1 from model_likes
    where user_id = user_uuid and model_id = model_uuid
  ) into like_exists;
  
  return like_exists;
end;
$$ language plpgsql stable;

-- 检查用户是否收藏了模型
create or replace function has_collected_model(user_uuid uuid, model_uuid uuid)
returns boolean as $$
declare
  collection_exists boolean;
begin
  select exists(
    select 1 from model_collections
    where user_id = user_uuid and model_id = model_uuid
  ) into collection_exists;
  
  return collection_exists;
end;
$$ language plpgsql stable;

/**
* 用户互动的存储过程
* Note: 提供便捷的交互操作
*/

-- 关注用户存储过程
create or replace procedure follow_user(
  follower_uuid uuid,
  followed_uuid uuid
)
language plpgsql
as $$
begin
  -- 不能关注自己
  if follower_uuid = followed_uuid then
    raise exception '用户不能关注自己';
  end if;
  
  -- 不能关注已删除的用户
  if exists (select 1 from users where id = followed_uuid and is_deleted) then
    raise exception '不能关注已删除的用户';
  end if;
  
  -- 插入关注记录
  insert into user_follows (follower_id, followed_id)
  values (follower_uuid, followed_uuid)
  on conflict (follower_id, followed_id) do nothing;
  
  commit;
end;
$$;

-- 取消关注用户存储过程
create or replace procedure unfollow_user(
  follower_uuid uuid,
  followed_uuid uuid
)
language plpgsql
as $$
begin
  delete from user_follows
  where follower_id = follower_uuid and followed_id = followed_uuid;
  
  commit;
end;
$$;

-- 点赞模型存储过程
create or replace procedure like_model(
  user_uuid uuid,
  model_uuid uuid
)
language plpgsql
as $$
begin
  -- 检查模型是否存在且未删除
  if not exists (select 1 from models where id = model_uuid and not is_deleted) then
    raise exception '模型不存在或已删除';
  end if;
  
  -- 插入点赞记录
  insert into model_likes (user_id, model_id)
  values (user_uuid, model_uuid)
  on conflict (user_id, model_id) do nothing;
  
  commit;
end;
$$;

-- 取消点赞模型存储过程
create or replace procedure unlike_model(
  user_uuid uuid,
  model_uuid uuid
)
language plpgsql
as $$
begin
  delete from model_likes
  where user_id = user_uuid and model_id = model_uuid;
  
  commit;
end;
$$;

-- 收藏模型存储过程
create or replace procedure collect_model(
  user_uuid uuid,
  model_uuid uuid
)
language plpgsql
as $$
begin
  -- 检查模型是否存在且未删除
  if not exists (select 1 from models where id = model_uuid and not is_deleted) then
    raise exception '模型不存在或已删除';
  end if;
  
  -- 插入收藏记录
  insert into model_collections (user_id, model_id)
  values (user_uuid, model_uuid)
  on conflict (user_id, model_id) do nothing;
  
  commit;
end;
$$;

-- 取消收藏模型存储过程
create or replace procedure uncollect_model(
  user_uuid uuid,
  model_uuid uuid
)
language plpgsql
as $$
begin
  delete from model_collections
  where user_id = user_uuid and model_id = model_uuid;
  
  commit;
end;
$$;

-- 记录模型下载存储过程
create or replace procedure record_model_download(
  user_uuid uuid,
  model_uuid uuid,
  ip_addr text default null,
  user_agent_str text default null
)
language plpgsql
as $$
begin
  -- 检查模型是否存在且未删除
  if not exists (select 1 from models where id = model_uuid and not is_deleted) then
    raise exception '模型不存在或已删除';
  end if;
  
  -- 插入下载记录
  insert into model_downloads (user_id, model_id, ip_address, user_agent)
  values (user_uuid, model_uuid, ip_addr, user_agent_str);
  
  commit;
end;
$$;

-- 为RLS更新认证函数，以访问这些新建视图和功能
alter table user_following_view security invoker;
alter table user_followers_view security invoker;
alter table model_likers_view security invoker;
alter table model_collectors_view security invoker;
alter table model_downloaders_view security invoker;

grant execute on function get_user_following to authenticated;
grant execute on function get_user_followers to authenticated;
grant execute on function get_model_likers to authenticated;
grant execute on function get_model_collectors to authenticated;
grant execute on function get_model_downloaders to authenticated;
grant execute on function is_following to authenticated;
grant execute on function has_liked_model to authenticated;
grant execute on function has_collected_model to authenticated;

grant execute on procedure follow_user to authenticated;
grant execute on procedure unfollow_user to authenticated;
grant execute on procedure like_model to authenticated;
grant execute on procedure unlike_model to authenticated;
grant execute on procedure collect_model to authenticated;
grant execute on procedure uncollect_model to authenticated;
grant execute on procedure record_model_download to authenticated;